#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Fri Sep 20 14:51:22 2019

@author: jan
"""
import gurobipy as gu
from reaction_class import Reaction
import cobra
from copy import deepcopy


def create_EX_reactions(metab_dict, direction = 'both'):
    '''
    Create an exchange reaction  for external metabolites in a metab_dict.
    
    Direction can be either 'import', 'export', 'both'
    '''
    EX_reactions = {}
    for metab in metab_dict:
        if '_e' in metab:
            EX_reaction_name = 'EX_' + metab[0:8] + '_e0'
            if direction=='import':
                EX_reactions[EX_reaction_name] = {'lower_bound': -1., 'upper_bound': 0., 'metabolites': {metab:-1.}} 
            elif direction=='export':
                EX_reactions[EX_reaction_name] = {'lower_bound': 0, 'upper_bound': 1., 'metabolites': {metab:-1.}}
            else:
                EX_reactions[EX_reaction_name] = {'lower_bound': -1., 'upper_bound': 1., 'metabolites': {metab:-1.}}
        
    return EX_reactions

def build_gurobi_model(reaction_dict, metabolite_dict, objective_name, model_reactions, candidate_reactions, delta):
    """
    Builds a gurobi model with a variable for each reaction in reaction dict,
    constrains variables using the metabolite dict, and sets the objective of the model.
    
    The objective is based on the candidate dict, method, objective name and delta.
    
    Candidate dict includes all reactions that are considered for gap filling, mapping to their cost.
    
    The objective of the model is defined as:
        MAXIMIZE: delta * objective_name (biomass reaction) - sum(cost * variable in candidate reactions)
    
    Parameters
    ----------
    reaction_dict : dict
    reaction_dict formated for gurobi. All reactions (draft + database)
    This is generated by the Reaction class with the .get_gurobi_reaction_dict() function.
    [reaction_id] : (lower_bound, upper_bound)
    
    metabolite_dict :dict
    metabolite_dict formated for gurobi. All metabolites (draft + database)
    This is generated by the Reaction class with the .get_gurobi_metabolite_dict() function.
    [metabolite_id] : {[reactio_id] : stoichiometry}
    
    objective_name : str
    name of the reaction to use as an objective.
    
    model_reactions : set
    reactions that are in the draft model
        
    candidate_reactions : dict
    candidate reactions to add (reactions that are not in the draft model) mapped to a cost
    reactions with low costs are more likely to be included
    [reaction_id] : cost,
    
    
    #export_reactions : 
    #media reactions
    
    delta :float
    parameter of the objective function
    """
    #define the model
    m= gu.Model('mipl')
    #define variables
    for i in reaction_dict:
        b=m.addVar(vtype= gu.GRB.CONTINUOUS, name = i, lb = reaction_dict[i][0], ub = reaction_dict[i][1])
            
    m.update()
    #set the objective function
    var = m.getVars()
    coef=[]
    for i in var:
        if i.VarName==objective_name:
            coef.append(delta)
            
        elif i.VarName in candidate_reactions:
            cost = candidate_reactions[i.VarName]
            coef.append(-cost) #Costs are assumed to be positive numbers in input.
            
        elif i.VarName in model_reactions: #reactions in the draft model have cost zero
            coef.append(0)
            
        # elif i.VarName in export_reactions: #export reactions have cost zero
        #     coef.append(0)
            
        else:
            print ('Cannot set objective for %s, not objective_name, model, export or candidate reaction!' %i.VarName)

    m.setObjective(gu.LinExpr(coef, var), gu.GRB.MAXIMIZE) #set the objective expression
    m.update()    
    #set the stoichiometric constraints for metabolites    
    for i in metabolite_dict:
        var = metabolite_dict[i].keys()
        var = [m.getVarByName(z) for z in var]
        coef = metabolite_dict[i].values()
        m.addConstr(gu.LinExpr(coef, var), 'E', 0, i)  
        
    m.update()
    m.setParam('OutputFlag', False) #Keep gurobi silent
    m.optimize()
    return m

def get_minimum(R, R_flux, R_cost, D, criteria=None):
    
    '''
    Each iteraction of the latendress_gapfill generates a viable gapfilling set.
    Select one based on different criteria: 
        - min_cost: minimun sum of costs in the added reactions
        
        - min_reactions: smallest number of added reactions
        
        - min_flux: smallest sum of fluxes
        
        - else the last iteration is chosen    
    
    Returns
    ------
    The selected reaction set and the value of delta
        
    '''
    
    if criteria == 'min_cost':
        sum_cost = [sum(cost) for cost in R_cost]
        if sum_cost != []:
            min_cost = min(sum_cost)
            min_cost_index = sum_cost.index(min_cost)
            return R[min_cost_index], D[min_cost_index]
    
    if criteria == 'min_reactions':
        len_reactions = [len(e) for e in R]
        if len_reactions != []:
            min_reactions = min(len_reactions)
            min_reactions_index = len_reactions.index(min_reactions)
            return R[min_reactions_index], D[min_reactions_index]
    
    if criteria == 'min_flux':
        sum_flux = [sum(flux) for flux in R_flux]
        if sum_flux != []:
            min_flux = min(sum_flux)
            min_flux_index = sum_flux.index(min_flux)
            return R[min_flux_index], D[min_flux_index]
    
    else:
        return R[-1], 0
    
def latendresse_gapfill(all_reactions_split, N, M, B, output):
    """
    Function based on Latendresse BMC Bioinformatics 2014.
    Input:
        all_reactions_split is Reaction class object containing data for all reactions.
        N is reactions in draft model.
        M is dictionary of all candidate reactions mapping to their cost.
        split_EX_reactions are all environment defining reactions that the model can use, 
            these are not associated to a cost, hence not found in M.
        B is the name of the biomass reaction.
    Output:
        List of the minimum set of candidate reactions to add to gapfill the model.
    """
    R = [] #reaction sets
    R_flux = [] #reaction fluxes
    R_cost = [] #reaction costs
    D = [] #deltas
    alpha = 0
    beta = 2 * len(M)
    
    #format reactions for gurobi model
    reaction_dict = all_reactions_split.get_gurobi_reaction_dict(all_reactions_split.reactions.keys())
    
    #format metabolites for gurobi_model
    metabolite_dict = all_reactions_split.get_gurobi_metabolite_dict(all_reactions_split.reactions.keys())
    
    
    #main loop
    while abs(alpha - beta) > 1:
        delta = int((alpha + beta) / 2.0) #Take the floor function of the mean of alpha and beta.
        print ('Delta is {:.2f}'.format(delta))
        gu_model = build_gurobi_model(reaction_dict, metabolite_dict, B, N, M, delta)
        if gu_model.getVarByName(B).X > 0:
            print ('Flux through biomass reaction is {:.8f}'.format(gu_model.getVarByName(B).X))
            beta = delta
            
            #Store results      
            
            #reaction ids
            R.append([var.VarName for var in gu_model.getVars() if var.VarName in N or gu_model.getVarByName(var.VarName).X > 0])
            
            # reaction fluxes
            R_flux.append([gu_model.getVarByName(e).X for e in M if gu_model.getVarByName(e).X > 0])
            
            #costs of candidate reactions retained in the model
            R_cost.append([M[e] for e in M if gu_model.getVarByName(e).X > 0])
            
            #delta
            D.append(delta)
           
        else:
            print ('Flux through biomass reaction is {:.8f}'.format(gu_model.getVarByName(B).X))
            alpha = delta
            
    minimum_set = get_minimum(R, R_flux, R_cost, D) #List that has minimum nr of reactions, sum of cost or sum of flux, dependend on output.
    return  minimum_set



def make_cobra_metabolites(metab_dict):
    '''
    Make a cobra metabolite object for each metabolite in metab_dict.
    Return a dict mapping the metab_id (str) : object.
    '''
    cobra_metabs = {}
    for metab in metab_dict:
        cobra_metabs[metab] = cobra.Metabolite(metab)
        if '_c' in metab:
            cobra_metabs[metab].compartment = 'c'
        
        elif '_e' in metab:
            cobra_metabs[metab].compartment = 'e'
            
    return cobra_metabs
        
def make_cobra_reaction(reaction_dict, cobra_metabs, rxn):
    '''
    Make a cobra reaction object from a rxn, setting the bounds, and adding metabolites.
    Return the cobra reaction object.
    '''
    reaction = cobra.Reaction(rxn)
    reaction.name = rxn
    reaction.lower_bound = reaction_dict[rxn]['lower_bound']
    reaction.upper_bound = reaction_dict[rxn]['upper_bound']
    metabolites = {cobra_metabs[k]:v for k,v in reaction_dict[rxn]['metabolites'].items()}
    reaction.add_metabolites(metabolites)
    return reaction

def make_cobra_model(reaction_dict, metab_dict, reactions_in_model, objective_name):
    '''
    Make a cobra model of all reactions in reactions_in_model, 
    using a reaction class instance and a metab dict containing all metabs used in the reactions.
    '''
    #Make cobra metabolites and reaction objects.
    cobra_metabs = make_cobra_metabolites(metab_dict)
    cobra_reactions = [make_cobra_reaction(reaction_dict, cobra_metabs, e) for e in reactions_in_model]
    #Make cobra model.
    cobra_model = cobra.Model('tempmodel')
    cobra_model.add_reactions(cobra_reactions)
    cobra_model.objective = objective_name
    return cobra_model



def gapfill(all_reactions, draft_reaction_ids, candidate_reactions, obj_id, medium = 'complete', default_cost = 1,
            compare_to_added_reactions = False, output_reactions = True, latendresse_result_selection = 'min_cost'):
    '''
    Gapfill an incomplete model using the following input:
        - all_reactions 
            This is a Reaction class object containing the chemical information of all reactions 
            (bounds, stoichiometry and metabolites).
            
        - draft_reaction_ids 
            This is a set containing all the reaction ids in the input model for gap filling.
            
        - candidate_reactions 
            This is a dictionary mapping reaction_ids to their cost during gap filling. When reactions are not present in 
            candidate_reactions, their cost will be default_cost.
            
        - obj_id 
            This is the id correspoding to the biomass reaction in all_reactions_split.
            
        - medium 
            This determines the EX_reactions that the model can use. As default a complete medium is assumed, where the model
            can use all extracellular metabolites that are defined in all_reactions. (This means they are available extra cellularly, 
            not that a transport reaction is added by default!) A reaction class can be given to medium for custom media.
            
        - default_cost
            Every reaction in all_reactions that is not in candidate_reactions or A_incomplete_reaction_ids will get this cost for
            gap filling.
    
    Output:
            
        - compare_to_added_reactions 
            This evalutates all reactions by comparing reactions added during gap filling to the reactions that are given as a set to 
            compare_to_added_reactions. Reactions in compare_added_reactions that are found back in the reactions added during gapfilling
            are counted as TP, added reactions that were not in compare_to_added_reactions are counted as FP, reactions that were not
            in compare_to_added_reactions and not added are counted as TN and reactions that were in compare_to_added_reactions but not added are counted as FN.
            The TP, FP, TN, FN are then returned.
            
            
        - output_reactions 
            This returns the set of reaction ids that were added during gap filling.
            
        - latendresse_result_selection 
            This is the parameter that specifies which of the gapfill solutions should be returned.
            It can either be the set that has the lowest cost ("min_cost") [default], lowest number of reactions ("min_reactions"), 
            or the lowest flux ("min_flux").
            
    Reactions from all_reactions are added to candidate_reactions if they are not in A_incomplete_reaction_ids or candidate_reactions. 
    This ensures that all reactions are considered as candidates during gap filling, while only reactions given as input with 
    candidate_reactions have a custom cost.
    During gap filling reactions are made unidirectional, so bidirectional reactions are split into a forward and reverse version.
    EX_reactions are added to the model. These specifiy which metabolites are avaiable in the medium. When no custom medium is used,
    the model will be gap filled on a complete medium. The model is gap filled, and the result is changed back into bidirectional reactions.
    Reactions added during gap filling are stored in the set added_reactions. This can be used to calculate TP, FP, TN and FN, where
    added EX reactions are not counted.
    '''
    
    #Create medium-defining external reactions or use ex_reactions from custom medium.
    if medium == 'complete':
        metabolites = all_reactions.get_gurobi_metabolite_dict()
        
        ex_reactions = Reaction()
        ex_reactions.reactions = create_EX_reactions(metabolites)
        
        
        
    
    else:
        ex_reactions = Reaction()
        ex_reactions.reactions = medium#same format as the output of the function create_EX_reactions
        
    all_reactions.reactions = all_reactions.add_dict(all_reactions.reactions, ex_reactions.reactions)
    
    
    #Add reactions from all_reactions to candidate_reactions, with cost = default_cost.
    for reaction in all_reactions.reactions:
        if (reaction not in draft_reaction_ids) and (reaction not in candidate_reactions):
            candidate_reactions[reaction] = default_cost
    
    for reaction in candidate_reactions:
        if reaction in draft_reaction_ids:
            del candidate_reactions[reaction] #Delete reaction from candidate_reactions if it is present in the starting model.
        
    #Split bidirectional reactions into a forward and reverse reaction.
    all_reactions_split = Reaction()
    
    all_reactions_split.reactions = all_reactions.split_all_bidirectional_reactions(reaction_dictionary=all_reactions.reactions)
    
    #Add reverse reactions to draft_reaction_ids_split and candidate_reactions.
    draft_reaction_ids_split = set()
    
    for reaction in all_reactions_split.reactions:
        forward_version = reaction.replace('_r', '')
        if forward_version in draft_reaction_ids:
            draft_reaction_ids_split.add(reaction)
        else:#If forward version of a reverse reaction is in candidate_reactions.
            if '_r' in reaction:
                candidate_reactions[reaction] = candidate_reactions[forward_version] #Give reverse reaction same cost as forward version.
    
        
    
    #Run gapfilling algorithm
    split_gapfill_result, delta = latendresse_gapfill(all_reactions_split, draft_reaction_ids_split, candidate_reactions, obj_id, latendresse_result_selection)
    
    gapfill_result = set([r.replace('_r', '') for r in split_gapfill_result])
    
    added_reactions = gapfill_result.difference(draft_reaction_ids) #All reactions that are added to the model during gapfilling.
    #Create cobra model
    
    metab_dict = all_reactions.get_gurobi_metabolite_dict(all_reactions.reactions.keys())
    
    cobra_model = make_cobra_model(all_reactions.reactions, metab_dict, gapfill_result, obj_id)
    
    objective_value = cobra_model.optimize().objective_value
    
    print ('Objective value is %f.' %objective_value)

   
    return cobra_model, objective_value, added_reactions


    
        
        
        
    
    
    
